package roesler821775.a01;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;

public class Main {

	static String name = "doc/a01.png";
	static int width = 480;
	static int height = 270;

	public static void main(String[] args) {
		BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);

		for (int x = 0; x != width; x++) {
			for (int y = 0; y != height; y++) {
				image.setRGB(x, y, colorForRedCircleOnColoredBackground(x, y));
			}
		}

		try {
			File outputfile = new File(name);
			ImageIO.write(image, "png", outputfile);
			System.out.println("Wrote image: " + name);
		} catch (IOException e) {
			System.out.println("Something went wrong: " + e);
		}
	}

	static int colorForRedCircleOnColoredBackground(int x, int y) {
		int radius = 100;
		int var = 0;
		int middleHeight = height / 2;
		int middleWidth = width / 2;
		// Rechteck
		// if (Math.abs(width / 2 - x) < size / 2 && Math.abs(height / 2 - y) <
		// size / 2)
		// return new Color(255, 0, 0).getRGB();
		// Kreis

		// Die if-Bedingugn pr¸ft, ist der Pixel innerhalb der Form (Kreis) oder
		// nicht.
		// Je nachdem wird eine andere Farbe gew‰hlt.
		// Kreisformel nach r umgestell: r*r = x2 + y2

		/**
		 * Um den Mittelpunkt zu setzen, Bei jedem Durchlauf wird die X und y
		 * Komponente des Pixels von den Koordinaten des Kreismittelpunkts
		 * abgezogen und f¸r x uny in die Formel eingesetzt Dadurch enth‰lt man
		 * den Abstand R des Pixels zum Mittelpunkt. Dieser Abstand wird mit dem
		 * festgelegten Radius verglichen. Je nachdem, ob der Punkt innerhalb
		 * oder auﬂerhalb des
		 **/
		if (radius * radius > (middleWidth - x) * (middleWidth - x) + (middleHeight - y) * (middleHeight - y)) {
			return new Color(255, 0, 0).getRGB();
		} else {
			// Hintergrund:
			// 255 is maximaler Wert einer Farbe
			// RGB alle 255 = weiﬂ
			// Am anfang hat y die Koordinate (0,0)
			// Das bedeutet wenn wir starten hat y den Wert 0
			// Dann wird die Spalte (x) durchgegangen
			// x soll sich auf der ganzen Zeile nicht ver‰ndern
			// Beim ersten Durchlauf der Vorschleife steht also var = 255 - (0 /
			// 2)
			// damit wird returned (255, 255, 255) also weiﬂ
			// Nehmen wir bei R und G langsam die Werte runter erhalten wir
			// irgendwann blau
			// Der Verlauf soll vertikal gehen
			var = 255 - (y / 2);
			return new Color(var, 255, 255).getRGB();
		}
	}
}
